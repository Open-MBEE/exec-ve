const path = require('path')
const fs = require('fs')

const webpack = require('webpack')
const CopyPlugin = require('copy-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const FaviconsWebpackPlugin = require('favicons-webpack-plugin')


const environment = require('./environment')

const packageJson = require("./package.json");
let sourceDir = './ve-custom'
let compileDir = './src/ve-extensions/custom'


class WatchRunPlugin {
    apply(compiler) {
        compiler.hooks.watchRun.tap('WatchRun', (comp) => {
            if (comp.modifiedFiles) {
                const changedFiles = Array.from(comp.modifiedFiles, (file) => `\n  ${file}`).join('');
                console.log('');
                console.log('===============================');
                console.log('FILES CHANGED:', changedFiles);
                console.log('===============================');
            }
            if (comp.removedFiles) {
                const changedFiles = Array.from(comp.removedFiles, (file) => `\n  ${file}`).join('');
                console.log('');
                console.log('===============================');
                console.log('FILES REMOVED:', changedFiles);
                console.log('===============================');
            }
        });
    }
}

class SetupPlugin {
    apply(compiler) {
        compiler.hooks.beforeCompile.tap('Setup',async(comp) =>{
            const configObj = await require(`./config/${process.env.VE_ENV}.json`)

            await fs.rmdir(compileDir, { recursive: true }, (err) => {
                if (err) {
                    throw err;
                }}
                )
            await fs.mkdir(compileDir, { recursive: true },(err) => {
                if (err) {
                    throw err;
                }});
            await fs.writeFile(`${compileDir}/index.ts`, '//** Automatically Generated by Webpack do not edit **//', (err) => {
                if (err) {
                    throw err;
                }}
            );

            if (configObj.extensions) {
                let validExt = ['content', 'transclude', 'view'];
                for (let extType of validExt) {
                    if (configObj.extensions[extType]) {
                        for (let extension of configObj.extensions[extType]) {
                            let ext = extension;
                            if (ext.path) {
                                let path = ext.path;
                                let extPath = ''
                                if (!ext.path.startsWith('.') && !ext.path.startsWith('/')) {
                                    extPath = path.resolve(__dirname, sourceDir, extType, ext.path);
                                }else {
                                    extPath = ext.path;
                                }

                                fs.copyFileSync(extPath, `${compileDir}/${path.basename(extPath)}`)


                            }
                        }
                    }
                }
            }
            let mode = (argv.mode === 'development') ? "-dev" : ""
            packageJson.then(() => {
                configObj.version = `${packageJson.version}${mode}`;
                fs.writeFile('./dist/config/config.json', JSON.stringify(configObj));
            })
        })
    }
}

module.exports = (env, argv) => {
    let ckpath = (argv.mode === 'development') ? "ckeditor-dev" : "ckeditor"

    return {
        experiments: {
            topLevelAwait: true
        },
        devtool: 'eval',
        entry: {
            veApp: {
                import: path.resolve(environment.paths.source, 'main.ts'),
            },
            // veDirectives: {
            //     import: './src/mms-directives/mms-directives.main.ts',
            //     dependOn: 'shared',
            // },
            // shared: [
            //     'angular',
            //     //'@uirouter/angularjs'
            // ],
        },

        optimization: {
            minimize: false,
        },
        output: {
            path: path.resolve(__dirname, 'dist'),
            filename: 'js/[name].bundle.js',
            assetModuleFilename: '[name][ext]',
            publicPath: '/',
        },
        watch: true,
        resolve: {
            modules: [path.resolve(__dirname, 'node_modules'), 'node_modules'],
            // Add '.ts' and '.tsx' as a resolvable extension.
            extensions: ['.webpack.js', '.web.js', '.ts', '.tsx', '.js'],
            alias: {
                buffer: 'buffer',
            },
        },
        watchOptions: {
            aggregateTimeout: 300,
            poll: 300,
            ignored: ['**/node_modules/', '**/ckeditor-dev/', '**/partials'],
        },
        plugins: [
            new WatchRunPlugin(),
            new SetupPlugin(),
            new webpack.EnvironmentPlugin({
                VE_ENV: 'local',
            }),
            new HtmlWebpackPlugin({
                title: 'View Editor',
                template: path.resolve(environment.paths.source, 'index.ejs'),
            }),
            new FaviconsWebpackPlugin({
                logo: path.resolve(
                    __dirname,
                    'src/assets/icons/favicon-32.png'
                ),
                prefix: '',
                publicPath: '../favicons',
                outputPath: path.resolve(__dirname, 'dist/favicons'),
                inject: true,
            }),
            new MiniCssExtractPlugin({
                filename: 'css/[name].min.css',
            }),
            new webpack.ProvidePlugin({
                $: 'jquery',
                jQuery: 'jquery',
            }),
            new CopyPlugin({
                patterns: [
                    {
                        from: path.resolve(
                            __dirname,
                            'config',
                            `config.js`
                        ),
                        to: path.resolve(
                            environment.paths.output,
                            'config',
                            'config.js'
                        ),
                    },
                    {
                        from: path.resolve(
                            environment.paths.source,
                            'partials'
                        ),
                        to: path.resolve(environment.paths.output, 'partials'),
                    },
                    {
                        from: path.resolve(
                            environment.paths.source, 'lib', ckpath
                        ),
                        to: path.resolve(environment.paths.output, ckpath)
                    },
                    {
                        from: path.resolve(
                            environment.paths.source, 'lib', 'ckeditor-plugins'
                        ),
                        to: path.resolve(environment.paths.output, ckpath, 'plugins')
                    },
                    {
                        from: path.resolve(
                            './node_modules', 'jquery', 'dist', 'jquery.js'
                        ),
                        to: path.resolve(environment.paths.output, 'js', 'jquery.js')
                    },
                    {
                        from: path.resolve(
                            environment.paths.source, 'errors'
                        ),
                        to: path.resolve(environment.paths.output, 'errors')
                    }
                ],
            }),
        ],
        module: {
            rules: [
                {
                    test: /\.(png|jpg|gif|svg)$/,
                    type: 'asset/resource',
                    generator: {
                        filename: 'img/[name][ext]',
                    },
                },
                {
                    test: /.(ttf|otf|eot|woff(2)?)(\?[a-z0-9]+)?$/,
                    type: 'asset/resource',
                    generator: {
                        filename: 'fonts/[name][ext]',
                    },
                },
                {
                    test: /\.s[ac]ss$/i,
                    use: [
                        MiniCssExtractPlugin.loader,
                        // Translates CSS into CommonJS
                        {
                            loader: 'css-loader',
                            options: {
                                sourceMap: true,
                            },
                        },

                        'resolve-url-loader',
                        // Compiles Sass to CSS
                        {
                            loader: 'sass-loader',
                            options: {
                                sourceMap: true,
                            },
                        },
                    ],
                },
                // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
                { test: /\.tsx?$/, loader: 'ts-loader' },
            ],
        },
    }
}
