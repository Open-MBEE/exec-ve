import * as path from 'path';
import * as fs from 'fs';

import * as webpack from 'webpack';

import CopyPlugin from 'copy-webpack-plugin';
import HtmlWebpackPlugin from 'html-webpack-plugin';
import MiniCssExtractPlugin from 'mini-css-extract-plugin';
import FaviconsWebpackPlugin from 'favicons-webpack-plugin';
import {AutomaticPrefetchPlugin, Compiler, Configuration} from "webpack";

const hq = require('alias-hq');

import environment from './src/lib/environment'

const packageJson = require("./package.json");
let sourceDir = './ve-custom'
let extensionsDir = './src/ve-extensions'



class WatchRunPlugin implements AutomaticPrefetchPlugin {
    apply(compiler: Compiler) {
        compiler.hooks.watchRun.tap('WatchRun', (comp) => {
            if (comp.modifiedFiles) {
                const changedFiles = Array.from(comp.modifiedFiles, (file) => `\n  ${file}`).join('');
                console.log('');
                console.log('===============================');
                console.log('FILES CHANGED:', changedFiles);
                console.log('===============================');
            }
            if (comp.removedFiles) {
                const changedFiles = Array.from(comp.removedFiles, (file) => `\n  ${file}`).join('');
                console.log('');
                console.log('===============================');
                console.log('FILES REMOVED:', changedFiles);
                console.log('===============================');
            }
        });
    }
}

class SetupPlugin {
    private readonly mode
    private ran
    constructor(mode) {
        this.mode = (mode === 'development') ? "-dev" : ""
        this.ran = false;
    }
    apply(compiler) {
        compiler.hooks.beforeCompile.tap('Setup',async(comp) =>{

            const configObj = await require(`./config/${process.env.VE_ENV}.json`)
            if (this.ran) {
                return;
            }
            this.ran = true;
            if (configObj.extensions) {
                const validExt = ['specTools', 'transclusions', 'presentations'];
                await fs.writeFile(`${extensionsDir}/index.ts`, '//** Automatically Generated by Webpack do not edit **//', (err) => {
                    if (err) {
                        throw err;
                    }}
                );
                for (let ext of configObj.extensions) {
                    // if (!configObj.ran) {
                    let extPath = `./${ext.id}`
                    if (ext.path) {
                        extPath = path.resolve(sourceDir, ext.path);
                    }

                    fs.appendFile(`${extensionsDir}/index.ts`,`\nimport '${extPath}'`, (err) => {
                        if (err) {
                            throw err;
                        }
                    });
                    if (!configObj.extConfig) {
                        configObj.extConfig = {};
                        for (let type of validExt) {
                            configObj.extConfig[type] = [];
                        }
                    }
                    let extConfPath = `${extensionsDir}/${ext.id}/config.json`
                    if (ext.config) {
                        extConfPath = ext.config
                    }
                    let extConf = await require(extConfPath)
                    for (let extType of validExt) {
                        if (extConf[extType] && extConf[extType].length > 0) {
                            for (let ec of extConf[extType]) {
                                configObj.extConfig[extType].push(ec);
                            }
                        }
                    }
                }
            }
            await packageJson
            configObj.version = `${packageJson.version}${this.mode}`;
            fs.mkdirSync('./dist/config', { recursive: true });
            fs.writeFile(__dirname + '/dist/config/config.json', JSON.stringify(configObj), (err) => {
                if (err) {
                    throw err;
                }
            });
        })
    }
}

const config = (env: any, argv: any): Configuration =>({
        mode: (argv.mode) ? argv.mode : "production",
        experiments: {
            topLevelAwait: true
        },
        devtool: 'source-map',
        entry: {
            veApp: {
                import: path.resolve(environment.paths.source, 'main.ts'),
            },
            // veDirectives: {
            //     import: './src/mms-directives/mms-directives.main.ts',
            //     dependOn: 'shared',
            // },
            // shared: [
            //     'angular',
            //     //'@uirouter/angularjs'
            // ],
        },
        optimization: {
            minimize: (argv.mode === "production"),
        },
        output: {
            path: path.resolve(__dirname, 'dist'),
            filename: 'js/[name].bundle.js',
            assetModuleFilename: '[name][ext]',
            publicPath: '/',
        },
        watch: true,
        resolve: {
            modules: [path.resolve(__dirname, 'node_modules'), 'node_modules'],
            // Add '.ts' and '.tsx' as a resolvable extension.
            extensions: ['.webpack.js', '.web.js', '.ts', '.tsx', '.js'],
            alias: hq.get('webpack')
        },
        watchOptions: {
            aggregateTimeout: 300,
            poll: 300,
            ignored: ['**/node_modules/', '**/ckeditor-dev', '**/partials', '**/src/ve-experimental/index.ts'],
        },
        plugins: [
            new WatchRunPlugin(),
            new SetupPlugin(argv.mode),
            new webpack.EnvironmentPlugin({
                VE_ENV: 'local',
            }),
            new HtmlWebpackPlugin({
                title: 'View Editor',
                template: path.resolve(environment.paths.source, 'index.ejs'),
                templateParameters: {
                    ckPath: 'ckeditor'
                }
            }),
            new FaviconsWebpackPlugin({
                logo: path.resolve(
                    __dirname,
                    'src/assets/icons/favicon-32.png'
                ),
                prefix: '',
                publicPath: '../favicons',
                outputPath: path.resolve(__dirname, 'dist/favicons'),
                inject: true,
            }),
            new MiniCssExtractPlugin({
                filename: 'css/[name].min.css',
            }),
            new webpack.ProvidePlugin({
                $: 'jquery',
                jQuery: 'jquery',
            }),
            new CopyPlugin({
                patterns: [
                    {
                        from: path.resolve(
                            __dirname,
                            'config',
                            `config.js`
                        ),
                        to: path.resolve(
                            environment.paths.output,
                            'config',
                            'config.js'
                        ),
                    },
                    {
                        from: path.resolve(
                            environment.paths.source,
                            'partials'
                        ),
                        to: path.resolve(environment.paths.output, 'partials'),
                    },
                    {
                        from: path.resolve(
                            environment.paths.source, 'lib', 'ckeditor'
                        ),
                        to: path.resolve(environment.paths.output, 'ckeditor')
                    },
                    {
                        from: path.resolve(
                            environment.paths.source, 'lib', 'ckeditor-plugins'
                        ),
                        to: path.resolve(environment.paths.output, 'ckeditor', 'plugins')
                    },
                    {
                        from: path.resolve(
                            './node_modules', 'jquery', 'dist', 'jquery.js'
                        ),
                        to: path.resolve(environment.paths.output, 'js', 'jquery.js')
                    },
                    {
                        from: path.resolve(
                            environment.paths.source, 'errors'
                        ),
                        to: path.resolve(environment.paths.output, 'errors')
                    }
                ],
            }),
        ],
        module: {
            rules: [
                {
                    test: /\.(png|jpg|gif|svg)$/,
                    type: 'asset/resource',
                    generator: {
                        filename: 'img/[name][ext]',
                    },
                },
                {
                    test: /.(ttf|otf|eot|woff(2)?)(\?[a-z0-9]+)?$/,
                    type: 'asset/resource',
                    generator: {
                        filename: 'fonts/[name][ext]',
                    },
                },
                {
                    test: /\.s[ac]ss$/i,
                    use: [
                        // Creates `style` nodes from JS strings
                        "style-loader",
                        // Translates CSS into CommonJS
                        {
                            loader: 'css-loader',
                            options: {
                                sourceMap: true,
                            },
                        },

                        'resolve-url-loader',
                        // Compiles Sass to CSS
                        {
                            loader: 'sass-loader',
                            options: {
                                sourceMap: true,
                            },
                        },
                    ],
                },
                // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
                { test: /\.tsx?$/, loader: 'ts-loader' },
            ],
        }
});

export default config;
